#include <iostream>
#include <GL/glew.h>
#include <SFML/Window.hpp>
#include <math.h>
#include <string>

#define PI  3.141592

// Kody shaderów
const GLchar* vertexSource = R"glsl(
#version 150 core
in vec2 position;
in vec3 color;
out vec3 Color;
void main(){
Color = color;
gl_Position = vec4(position, 0.0, 1.0);
}
)glsl";

const GLchar* fragmentSource = R"glsl(
#version 150 core
in vec3 Color;
out vec4 outColor;
void main()
{
outColor = vec4(Color, 1.0);
}
)glsl";

void createVertices(int verticesNumber, GLuint vbo)
{

    GLfloat* vertices = new GLfloat[verticesNumber * 6];

    float alpha = (2 * PI) / verticesNumber;
    float temp = 0;

    for (int i = 0; i < verticesNumber*6; i+=6) 
    {
        vertices[i] = cos(temp);
        vertices[i+1] = sin(temp);
        vertices[i+2] = 0;
        vertices[i+3] = 0;
        vertices[i+4] = 1;
        vertices[i+5] = 0.5;
        temp+=alpha;
    }

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * verticesNumber * 6, vertices, GL_STATIC_DRAW);

    delete[] vertices;
}

int main()
{
    sf::ContextSettings settings;
    settings.depthBits = 24;
    settings.stencilBits = 8;

    // Okno renderingu
    sf::Window window(sf::VideoMode(800, 800, 32), "OpenGL", sf::Style::Titlebar | sf::Style::Close, settings);

    // Inicjalizacja GLEW
    glewExperimental = GL_TRUE;
    glewInit();

    // Utworzenie VAO (Vertex Array Object)
    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    // Utworzenie VBO (Vertex Buffer Object)
    // i skopiowanie do niego danych wierzchołkowych

    //TODO - czy
    GLuint vbo;
    glGenBuffers(1, &vbo);

    int verticesNumber = 8;
    
    createVertices(verticesNumber, vbo);


    // Utworzenie i skompilowanie shadera wierzchołków
    GLuint vertexShader =
        glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexSource, NULL);
    glCompileShader(vertexShader);

    //sprawdzenie poprawności vertex<--
    GLint status;
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS,
        &status);
    if (status) 
    {
        fprintf(stderr, "Vertex shader loaded succesfully!\n");
    }
    else 
    {
        char buffer[512];
        glGetShaderInfoLog(vertexShader, 512, NULL, buffer);
        fprintf(stderr, buffer);    //wypisanie zawartości error
    }
    

    // Utworzenie i skompilowanie shadera fragmentów
    GLuint fragmentShader =
        glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentSource, NULL);
    glCompileShader(fragmentShader);

    //sprawdzenie poprawności fragment<--
    GLint status2;
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS,
        &status2);
    if (status2)
    {
        fprintf(stderr, "Fragment shader loaded succesfully!\n");
    }
    else
    {
        char buffer[512];
        glGetShaderInfoLog(fragmentShader, 512, NULL, buffer);
        fprintf(stderr, buffer);    //wypisanie zawartości error
    }
    

    // Zlinkowanie obu shaderów w jeden wspólny program
    GLuint shaderProgram = glCreateProgram();

    //poprawność kompilacji shaderów <--------------------------

    if (shaderProgram == 0)
    {
        fprintf(stderr, "Error creating program object. \n");
        glGetError();
    }

    //GLenum ErrorCheckValue = glGetError();

    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glBindFragDataLocation(shaderProgram, 0, "outColor");
    glLinkProgram(shaderProgram);
    glUseProgram(shaderProgram);

    // Specifikacja formatu danych wierzchołkowych
    GLint posAttrib = glGetAttribLocation(shaderProgram, "position");
    glEnableVertexAttribArray(posAttrib);
    glVertexAttribPointer(posAttrib, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), 0);
    GLint colAttrib = glGetAttribLocation(shaderProgram, "color");
    glEnableVertexAttribArray(colAttrib);
    glVertexAttribPointer(colAttrib, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (void*)(3 * sizeof(GLfloat)));

    //wstępna definicja prymitywu
    int primitive = GL_TRIANGLE_FAN;

    // Rozpoczęcie pętli zdarzeń
    bool running = true;
    while (running) {


        sf::Event windowEvent;
        while (window.pollEvent(windowEvent)) {
            switch (windowEvent.type) {
            case sf::Event::Closed:
                running = false;
                break;
            case sf::Event::KeyPressed:

                switch (windowEvent.key.code)
                {
                case sf::Keyboard::Escape:
                    running = false;
                    break;
                case sf::Keyboard::Num0:
                    primitive = GL_POINTS;
                    break;
                case sf::Keyboard::Num1:
                    primitive = GL_LINES;
                    break;
                case sf::Keyboard::Num2:
                    primitive = GL_LINE_STRIP;
                    break;
                case sf::Keyboard::Num3:
                    primitive = GL_LINE_LOOP;
                    break;
                case sf::Keyboard::Num4:
                    primitive = GL_TRIANGLES;
                    break;
                case sf::Keyboard::Num5:
                    primitive = GL_TRIANGLE_STRIP;
                    break;
                case sf::Keyboard::Num6:
                    primitive = GL_TRIANGLE_FAN;
                    break;
                case sf::Keyboard::Num7:
                    primitive = GL_QUADS;
                    break;
                case sf::Keyboard::Num8:
                    primitive = GL_QUAD_STRIP;
                    break;
                case sf::Keyboard::Num9:
                    primitive = GL_POLYGON;
                    break;
                }
            }
        }


        // Nadanie scenie koloru czarnego
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        

        glDrawArrays(primitive, 0, verticesNumber);
        
       
        
        // Wymiana buforów tylni/przedni
        window.display();
    }
    // Kasowanie programu i czyszczenie buforów
    glDeleteProgram(shaderProgram);
    glDeleteShader(fragmentShader);
    glDeleteShader(vertexShader);
    glDeleteBuffers(1, &vbo);
    glDeleteVertexArrays(1, &vao);
    // Zamknięcie okna renderingu
    window.close();
    return 0;
}
